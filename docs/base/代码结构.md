# 机器人平台统一系统架构设计

## 1. 重构后的目录结构

```
robot_system_ws/
├── src/
│   ├── robot_interfaces/                  # 统一机器人接口层
│   │   ├── robot_base_interfaces/         # 基础抽象接口定义
│   │   │   ├── motion_interface/          # 运动控制抽象接口
│   │   │   ├── sensor_interface/          # 传感器数据抽象接口
│   │   │   ├── state_interface/           # 状态监控抽象接口
│   │   │   └── power_interface/           # 电源管理抽象接口
│   │   │
│   │   ├── robot_adapters/                # 具体机器人适配器
│   │   │   ├── go2_adapter/               # Go2适配器
│   │   │   ├── other_adapter/             # 其他机器人适配器（预留）
│   │   │   └── generic_adapter/           # 通用机器人适配器
│   │   │
│   │   └── robot_factory/                 # 机器人工厂模式实现
│   │       ├── robot_detector/            # 机器人型号自动检测
│   │       ├── adapter_factory/           # 适配器工厂
│   │       └── capability_manager/        # 能力管理器
│   │
│   ├── robot_common/                      # 通用功能模块
│   │   ├── common_msgs/                   # 统一消息类型定义
│   │   ├── common_transforms/             # 通用坐标变换
│   │   ├── common_utils/                  # 通用工具函数
│   │   └── robot_capabilities/            # 机器人能力定义
│   │
│   ├── navigation_core/                   # 核心导航模块（机器人无关）
│   │   ├── slam_manager/                  # SLAM管理器
│   │   ├── path_planner/                  # 路径规划器
│   │   ├── motion_controller/             # 运动控制器
│   │   ├── obstacle_avoidance/            # 避障算法
│   │   └── localization/                  # 定位管理器
│   │
│   ├── perception_core/                   # 感知模块（传感器无关）
│   │   ├── lidar_processor/               # 激光雷达数据处理
│   │   ├── camera_processor/              # 视觉数据处理
│   │   ├── imu_processor/                 # IMU数据处理
│   │   └── sensor_fusion/                 # 多传感器融合
│   │
│   ├── charging_systems/                  # 自主回充系统
│   │   ├── charging_core/                 # 回充核心逻辑
│   │   ├── power_management/              # 电源管理
│   │   ├── docking_controllers/           # 对接控制器
│   │   │   ├── wireless_docking/          # 无线充电对接
│   │   │   ├── contact_docking/           # 接触式充电对接
│   │   │   └── inductive_docking/         # 电磁感应对接
│   │   └── charging_behaviors/            # 回充行为控制
│   │
│   ├── applications/                      # 应用层模块
│   │   ├── task_manager/                  # 任务管理器
│   │   ├── map_manager/                   # 地图管理器
│   │   ├── fleet_manager/                 # 机器人管理器
│   │   └── system_monitor/                # 系统监控面板
│   │
│   ├── robot_bringup/                     # 系统启动管理
│   │   ├── launch_configs/                # 启动配置文件
│   │   │   ├── go2_launch/                # Go2启动配置
│   │   │   ├── other_launch/              # 其他机器人启动配置（预留）
│   │   │   └── generic_launch/            # 通用启动配置
│   │   └── robot_configurator/            # 机器人配置器
│   │
│   ├── simulation/                        # 仿真测试环境
│   │   ├── gazebo_worlds/                 # Gazebo仿真世界
│   │   ├── robot_models/                  # 机器人模型库
│   │   │   ├── go2_model/                 # Go2仿真模型
│   │   │   ├── other_model/               # 其他机器人仿真模型（预留）
│   │   │   └── generic_model/             # 通用机器人模型
│   │   └── testing_framework/             # 自动化测试框架
│   │
│   └── third_party/                       # 第三方依赖库
│       ├── go2_ros2/                      # Go2官方ROS2库
│       ├── other_ros2/                    # 其他机器人官方ROS2库（预留）
│       ├── navigation2/                   # Nav2导航框架
│       └── perception_libs/               # 感知算法库
│
├── configs/                               # 配置文件目录
│   ├── robot_configs/                     # 机器人配置
│   │   ├── go2_config.yaml                # Go2机器人配置
│   │   ├── other_config.yaml              # 其他机器人配置
│   │   └── capability_matrix.yaml         # 能力矩阵配置
│   ├── navigation_configs/                # 导航配置
│   ├── perception_configs/                # 感知配置
│   └── charging_configs/                  # 充电配置
│
├── data/                                  # 运行时数据目录
├── scripts/                               # 工具脚本目录
├── docs/                                  # 项目文档目录
└── docker/                                # 容器化部署
```

## 2. 统一接口设计架构

### 2.1 抽象接口层设计

```cpp
// 基础运动控制接口
class IMotionController {
public:
    virtual bool setVelocity(const Velocity& vel) = 0;
    virtual bool setPosture(const Posture& posture) = 0;
    virtual bool emergencyStop() = 0;
    virtual MotionCapabilities getCapabilities() = 0;
    virtual MotionState getState() = 0;
};

// 传感器数据接口
class ISensorInterface {
public:
    virtual bool initialize() = 0;
    virtual SensorData getData(SensorType type) = 0;
    virtual std::vector<SensorType> getAvailableSensors() = 0;
    virtual bool calibrateSensor(SensorType type) = 0;
};

// 状态监控接口
class IStateMonitor {
public:
    virtual RobotState getRobotState() = 0;
    virtual HealthStatus getHealthStatus() = 0;
    virtual std::vector<Alert> getAlerts() = 0;
    virtual bool isOperational() = 0;
};

// 电源管理接口
class IPowerManager {
public:
    virtual BatteryInfo getBatteryInfo() = 0;
    virtual bool requestCharging() = 0;
    virtual ChargingState getChargingState() = 0;
    virtual PowerCapabilities getPowerCapabilities() = 0;
};
```

### 2.2 机器人能力定义系统

```yaml
# capability_matrix.yaml - 机器人能力矩阵
robots:
  go2:
    motion_capabilities:
      max_linear_velocity: 1.5    # m/s
      max_angular_velocity: 2.0   # rad/s
      can_climb_stairs: true
      can_balance: true
      locomotion_modes: ["walk", "trot", "bound"]
    
    sensor_capabilities:
      lidar: 
        type: "livox_mid360"
        range: 40.0               # meters
        resolution: 0.01          # meters
      cameras:
        - type: "stereo"
          resolution: "1280x720"
        - type: "depth"
          range: 10.0
      imu:
        type: "6dof"
        frequency: 1000           # Hz
    
    power_capabilities:
      battery_capacity: 15000     # mAh
      charging_type: "wireless"
      operating_voltage: 25.2     # V
      charging_time: 120          # minutes
    
    physical_properties:
      length: 0.845               # meters
      width: 0.405                # meters  
      height: 0.32                # meters
      weight: 15.0                # kg

  spot:
    motion_capabilities:
      max_linear_velocity: 1.6    # m/s
      max_angular_velocity: 2.1   # rad/s
      can_climb_stairs: true
      can_balance: true
      locomotion_modes: ["walk", "trot", "stairs_mode"]
    
    sensor_capabilities:
      lidar:
        type: "velodyne_vlp16"
        range: 100.0              # meters
        resolution: 0.05          # meters
      cameras:
        - type: "stereo_front"
          resolution: "1920x1080"
        - type: "stereo_rear" 
          resolution: "1920x1080"
        - type: "stereo_left"
          resolution: "1920x1080"
        - type: "stereo_right"
          resolution: "1920x1080"
      imu:
        type: "9dof"
        frequency: 400            # Hz
    
    power_capabilities:
      battery_capacity: 25000     # mAh
      charging_type: "contact"
      operating_voltage: 48.0     # V
      charging_time: 180          # minutes
```

### 2.3 适配器工厂模式实现

```cpp
class RobotAdapterFactory {
public:
    static std::unique_ptr<IRobotAdapter> createAdapter(RobotType type) {
        switch(type) {
            case RobotType::GO2:
                return std::make_unique<Go2Adapter>();
            case RobotType::SPOT:
                return std::make_unique<SpotAdapter>();
            case RobotType::ANYMAL:
                return std::make_unique<AnymalAdapter>();
            default:
                return std::make_unique<GenericAdapter>();
        }
    }
    
    static RobotType detectRobotType() {
        // 自动检测机器人型号的逻辑
        // 通过网络发现、配置文件或环境变量
        return autoDetectRobot();
    }
};

class Go2Adapter : public IRobotAdapter {
private:
    std::unique_ptr<IMotionController> motion_controller_;
    std::unique_ptr<ISensorInterface> sensor_interface_;
    std::unique_ptr<IStateMonitor> state_monitor_;
    std::unique_ptr<IPowerManager> power_manager_;
    
public:
    bool initialize() override {
        // 初始化Go2特定的通信接口
        motion_controller_ = std::make_unique<Go2MotionController>();
        sensor_interface_ = std::make_unique<Go2SensorInterface>();
        state_monitor_ = std::make_unique<Go2StateMonitor>();
        power_manager_ = std::make_unique<Go2PowerManager>();
        
        return initializeUnitreeConnection();
    }
    
    IMotionController* getMotionController() override {
        return motion_controller_.get();
    }
    
    // 其他接口实现...
};
```

## 3. 核心设计原则

### 3.1 接口抽象化

- **运动控制统一化**：所有机器人的运动控制都抽象为速度、姿态和模式控制
- **传感器数据标准化**：统一传感器数据格式，支持不同传感器类型的透明切换
- **状态监控一致性**：提供统一的机器人状态、健康状况和告警信息接口

### 3.2 能力驱动设计

- **能力发现机制**：系统启动时自动检测机器人的具体能力
- **功能适配策略**：根据机器人能力自动调整算法参数和策略
- **降级处理机制**：当某些能力不可用时，提供合理的功能降级

### 3.3 插件化架构

- **热插拔支持**：支持运行时动态加载和卸载机器人适配器
- **配置驱动**：通过配置文件而非硬编码来适配不同机器人
- **扩展性保证**：新增机器人类型只需实现对应的适配器接口

## 4. 具体实现策略

### 4.1 机器人自动检测

```python
class RobotDetector:
    def detect_robot_type(self):
        # 1. 检查环境变量
        robot_type = os.getenv('ROBOT_TYPE')
        if robot_type:
            return robot_type
            
        # 2. 网络发现
        if self.discover_unitree_robot():
            return 'go2'
        elif self.discover_spot_robot():
            return 'spot'
            
        # 3. 配置文件检测
        config_robot = self.check_config_file()
        if config_robot:
            return config_robot
            
        # 4. 默认为通用机器人
        return 'generic'
```

### 4.2 能力映射与适配

```cpp
class CapabilityMapper {
public:
    NavigationConfig adaptNavigationConfig(const RobotCapabilities& caps) {
        NavigationConfig config;
        
        // 根据机器人运动能力调整导航参数
        config.max_vel_x = caps.motion.max_linear_velocity * 0.8;
        config.max_vel_theta = caps.motion.max_angular_velocity * 0.8;
        
        // 根据传感器能力选择SLAM算法
        if (caps.sensors.has_3d_lidar) {
            config.slam_type = SlamType::FAST_LIO2;
        } else if (caps.sensors.has_2d_lidar) {
            config.slam_type = SlamType::CARTOGRAPHER;
        } else {
            config.slam_type = SlamType::VISUAL_SLAM;
        }
        
        return config;
    }
};
```

### 4.3 消息转换层

```cpp
class MessageConverter {
public:
    // 将标准导航消息转换为机器人特定消息
    template<typename RobotMsgType>
    RobotMsgType convertTwist(const geometry_msgs::msg::Twist& twist) {
        return RobotSpecificConverter<RobotMsgType>::convert(twist);
    }
    
    // 将机器人特定消息转换为标准ROS消息
    template<typename RobotMsgType>
    nav_msgs::msg::Odometry convertOdometry(const RobotMsgType& robot_odom) {
        return RobotSpecificConverter<RobotMsgType>::convertToStandard(robot_odom);
    }
};
```

## 5. 启动配置管理

### 5.1 动态启动文件

```python
# dynamic_launch.py
def generate_launch_description():
    robot_type = RobotDetector().detect_robot_type()
    
    # 加载机器人特定配置
    robot_config = load_robot_config(robot_type)
    
    # 根据机器人能力选择启动的节点
    launch_actions = []
    
    # 基础接口层
    launch_actions.append(
        Node(
            package=f'{robot_type}_adapter',
            executable='robot_adapter_node',
            parameters=[robot_config]
        )
    )
    
    # 导航层（根据能力调整）
    if robot_config['capabilities']['navigation']:
        nav_config = adapt_navigation_config(robot_config)
        launch_actions.append(
            IncludeLaunchDescription(
                PythonLaunchDescriptionSource([
                    get_package_share_directory('navigation_core'),
                    '/launch/navigation.launch.py'
                ]),
                launch_arguments={'config': nav_config}.items()
            )
        )
    
    return LaunchDescription(launch_actions)
```

## 6. 优势分析

### 6.1 技术优势

- **统一开发体验**：开发者只需了解统一接口，无需关心底层机器人差异
- **代码复用性高**：核心算法模块可以在不同机器人平台间直接复用
- **维护成本低**：新增机器人支持只需开发对应适配器，无需修改核心逻辑

### 6.2 系统优势

- **热插拔能力**：支持运行时切换机器人类型或添加新机器人
- **向后兼容性**：新版本系统可以支持旧版本的机器人适配器
- **测试便利性**：可以在仿真环境中测试多种机器人类型

### 6.3 商业优势

- **市场适应性强**：同一套系统可以快速适配不同客户的机器人平台
- **技术壁垒高**：统一的抽象层和能力管理系统形成技术护城河
- **扩展性良好**：支持未来新兴机器人平台的快速接入

## 7. 迁移建议

### 7.1 从Go2专用系统迁移

1. **保留现有Go2代码**：将现有代码重构为Go2Adapter
2. **抽象核心接口**：提取导航、感知等核心功能为独立模块
3. **配置文件迁移**：将Go2特定配置整理为标准能力描述
4. **测试验证**：确保重构后的Go2功能与原系统一致

### 7.2 新机器人接入流程

1. **能力分析**：分析新机器人的运动、传感器和电源能力
2. **适配器开发**：在`robot_adapters/`下创建新机器人适配器文件夹
3. **配置文件编写**：在`capability_matrix.yaml`中添加新机器人配置
4. **工厂类更新**：在`RobotAdapterFactory`中添加新机器人类型的支持
5. **测试验证**：在仿真和真机环境中验证功能

### 7.3 目前的简化实现

- **只保留Go2相关代码**：避免创建用不到的文件夹和配置
- **预留扩展接口**：抽象层设计保证未来可以轻松添加新机器人
- **注释指导扩展**：在代码中用注释标明未来扩展的位置
- **配置驱动设计**：新机器人主要通过配置文件而非代码修改来支持

这种设计不仅解决了多机器人适配的问题，还为未来的技术发展预留了充分的扩展空间。